from openmdao.main.api import Component
from openmdao.lib.datatypes.api import Float
from openmdao.lib.datatypes.api import Enum
from openmdao.lib.datatypes.api import List
from openmdao.lib.datatypes.api import Slot
from openmdao.lib.datatypes.api import File
from openmdao.lib.datatypes.api import Str
from avl_geometry_surface import AVLSurface
from avl_geometry_surface import AVLSection
from avl_geometry_surface import AVLControlSurface

class AVLGeo(Component):
	name = Str("Geometry", iotype = 'in', desc = "Name of the geometry")
	mach = Float(0.0, iotype = 'in', 
		desc = "Mach number that the geometry will default to")
	yaxis_symmetry = Enum(
						"Symmetric", 
						("Symmetric", "Antisymmetric", "Asymmetric"),
						iotype = 'in')
	zaxis_symmetry = Enum(
						"Symmetric", 
						("Symmetric", "Antisymmetric", "Asymmetric"),
						iotype = 'in')
	sref = Float(11.5244, iotype = 'in', desc = "planform Wing Area")
	cref = Float(1.13627, iotype = 'in', desc = "cbar")
	bref = Float(10.142, iotype = 'in', desc = "wing span")
	xcg = Float(0.31, iotype = 'in', desc = "center of mass on the x")
	ycg = Float(0.00, iotype = 'in', desc = "center of mass on the y")
	zcg = Float(0.00, iotype = 'in', desc = "center of mass on the z")
	cdp = Float(0.0098379, iotype = 'in', desc = "coeff parasitic drag")
	surfaces = List( Slot(AVLSurface), iotype = 'in', desc = "surfaces")
	savefile = File(iotype = 'out', 
					desc = "The file in which the geometry was written")
	def execute(self):
		#Create output file
		path = "geometry.avl"
		with open(path, 'w') as out:
			out.write(self.name + "\n")
			out.write("#Autogenerated AVL Geometry\n\n")
			out.write(str(self.mach) + "\n")
			if self.yaxis_symmetry == "Symmetric":
				ysym = 1
			elif self.yaxis_symmetry == "Antisymmetric":
				ysym = -1
			elif self.yaxis_symmetry == "Asymmetric":
				ysym = 0
			if self.zaxis_symmetry == "Symmetric":
				zsym = 1
			elif self.zaxis_symmetry == "Antisymmetric":
				zsym = -1
			elif self.zaxis_symmetry == "Asymmetric":
				zsym = 0
			out.write(str(ysym) + "   " + 
					str(zsym) + "   " + 
					str(0) + "\n")
			out.write(str(self.sref) + "   " + 
					str(self.cref) + "   " + 
					str(self.bref) + "\n")
			out.write(str(self.xcg) + "   " +
					str(self.ycg) + "   " + 
					str(self.zcg) + "\n")
			out.write(str(self.cdp) + "\n\n\n\n")
			for surface in self.surfaces[:]:
				out.write("SURFACE\n")
				out.write(surface.name + "\n\n")
				out.write(str(surface.nchordwise) + "   " +
					str(surface.cspace) + "   " +
					str(surface.nspanwise) + "   " +
					str(surface.sspace) + "\n\n")
				if surface.isyduplicate == True:
					out.write("YDUPLICATE\n")
					out.write(str(surface.yduplicate) + "\n")
				out.write("SCALE\n" +
					str(surface.xscale) + "   " +
					str(surface.yscale) + "   " +
					str(surface.zscale) + "\n\n\n")
				for section in surface.sections[:]:
					out.write("SECTION\n")
					out.write(str(section.xle) + "   " +
						str(section.yle) + "   " +
						str(section.zle) + "   " +
						str(section.chord) + "   " +
						str(section.ainc) + "\n")
					out.write("NACA\n")
					out.write(str(section.NACA) + "\n")
					if section.hascontrol == True:
						out.write("CONTROL\n")
						out.write(str(section.ControlSurface.surface) +
							"   " + 
							str(section.ControlSurface.gain) + "   " +
							str(section.ControlSurface.xhinge) + "   " +
							str(section.ControlSurface.xhvec) + "   " +
							str(section.ControlSurface.yhvec) + "   " +
							str(section.ControlSurface.zhvec) + "   "  +
							str(section.ControlSurface.sgndup) + "\n\n")
					out.write("\n")
			out.write("#END")
			
			
	
	
						
	
